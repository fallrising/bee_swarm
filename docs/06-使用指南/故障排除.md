# 故障排除

## 本章概要

本章提供 Bee Swarm 項目使用過程中常見問題的診斷和解決方案，幫助快速定位和修復問題。

- **章節目標**：快速解決使用過程中的常見問題
- **主要內容**：問題診斷、解決方案、預防措施
- **閱讀收穫**：掌握問題解決技能，提高使用效率

## 🔍 問題診斷框架

### 問題分類
```mermaid
graph TD
    A[問題出現] --> B{問題類型}
    B -->|環境配置| C[環境問題]
    B -->|工具使用| D[工具問題]
    B -->|流程執行| E[流程問題]
    B -->|性能| F[性能問題]
    
    C --> C1[依賴缺失]
    C --> C2[版本衝突]
    C --> C3[權限問題]
    
    D --> D1[GitHub配置]
    D --> D2[模擬器問題]
    D --> D3[容器問題]
    
    E --> E1[協作流程]
    E --> E2[CI/CD問題]
    E --> E3[部署問題]
    
    F --> F1[模擬性能]
    F --> F2[系統資源]
    F --> F3[網絡問題]
```

### 診斷步驟
1. **問題重現** - 確認問題的可重現性
2. **環境檢查** - 驗證系統和軟件環境
3. **日誌分析** - 檢查相關日誌文件
4. **配置檢查** - 確認配置文件正確性
5. **逐步排除** - 使用排除法縮小問題範圍

## 🛠️ 環境配置問題

### Python 環境問題

#### 問題：ModuleNotFoundError
```bash
ModuleNotFoundError: No module named 'simpy'
```

**解決方案：**
```bash
# 1. 檢查 Python 版本
python --version
python3 --version

# 2. 檢查 pip 版本
pip --version
pip3 --version

# 3. 安裝缺失的包
pip install simpy
# 或者
pip3 install simpy

# 4. 使用 requirements.txt
pip install -r docs/05-模擬工具/scripts/requirements.txt

# 5. 使用虛擬環境（推薦）
python -m venv bee_swarm_env
source bee_swarm_env/bin/activate  # Linux/Mac
# 或
bee_swarm_env\Scripts\activate     # Windows

pip install -r requirements.txt
```

#### 問題：版本衝突
```bash
ERROR: pip's dependency resolver does not currently have backtracking
```

**解決方案：**
```bash
# 1. 清理 pip 緩存
pip cache purge

# 2. 升級 pip
pip install --upgrade pip

# 3. 創建新的虛擬環境
python -m venv fresh_env
source fresh_env/bin/activate
pip install -r requirements.txt

# 4. 指定特定版本
pip install simpy==4.0.1 numpy==1.21.0
```

#### 問題：權限錯誤
```bash
PermissionError: [Errno 13] Permission denied
```

**解決方案：**
```bash
# 1. 使用 --user 標誌
pip install --user simpy

# 2. 使用虛擬環境（推薦）
python -m venv myenv
source myenv/bin/activate
pip install simpy

# 3. macOS/Linux：使用 sudo（不推薦）
sudo pip install simpy

# 4. Windows：以管理員身份運行
# 右鍵點擊命令提示符，選擇"以管理員身份運行"
```

### Git 配置問題

#### 問題：認證失敗
```bash
remote: Support for password authentication was removed
fatal: Authentication failed
```

**解決方案：**
```bash
# 1. 生成 SSH 密鑰
ssh-keygen -t ed25519 -C "your_email@example.com"

# 2. 添加到 ssh-agent
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_ed25519

# 3. 添加公鑰到 GitHub
cat ~/.ssh/id_ed25519.pub
# 複製輸出，添加到 GitHub Settings > SSH keys

# 4. 或使用 Personal Access Token
git remote set-url origin https://USERNAME:TOKEN@github.com/USERNAME/REPOSITORY.git

# 5. 或使用 GitHub CLI
gh auth login
```

#### 問題：分支策略混亂
```bash
error: Your local changes would be overwritten by merge
```

**解決方案：**
```bash
# 1. 檢查狀態
git status

# 2. 暫存變更
git stash

# 3. 拉取最新代碼
git pull origin main

# 4. 恢復變更
git stash pop

# 5. 或創建新分支
git checkout -b feature/my-changes
git add .
git commit -m "Save my changes"
git push origin feature/my-changes
```

## 🔧 工具使用問題

### GitHub 相關問題

#### 問題：Issue 模板不生效
**症狀：** 創建 Issue 時沒有顯示模板選項

**解決方案：**
```bash
# 1. 檢查文件路徑
ls -la .github/ISSUE_TEMPLATE/

# 2. 確認文件格式
# 文件應為 .md 格式，YAML front matter 正確

# 3. 檢查 YAML 語法
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: 'bug'
assignees: ''
---

# 4. 提交並推送到遠程倉庫
git add .github/
git commit -m "Add issue templates"
git push origin main
```

#### 問題：GitHub Actions 失敗
**症狀：** CI/CD 流水線執行失敗

**診斷步驟：**
```yaml
# 1. 檢查 workflow 文件語法
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'

# 2. 檢查 secrets 配置
# Settings > Secrets and variables > Actions

# 3. 檢查 permissions
permissions:
  contents: read
  packages: write
```

### 模擬器問題

#### 問題：模擬運行緩慢
**症狀：** 模擬腳本執行時間過長

**解決方案：**
```python
# 1. 減少模擬持續時間
SIMULATION_DURATION = 100  # 從 1000 減少到 100

# 2. 降低日誌輸出級別
import logging
logging.getLogger('simpy').setLevel(logging.WARNING)

# 3. 優化數據收集
class OptimizedMetrics:
    def __init__(self, sample_rate=0.1):
        self.sample_rate = sample_rate
        
    def record_event(self, event):
        if random.random() < self.sample_rate:
            # 只記錄部分事件
            pass

# 4. 使用生成器而非列表
def generate_tasks():
    for i in range(1000):
        yield create_task(i)  # 生成器
        
# 而非
# tasks = [create_task(i) for i in range(1000)]  # 列表
```

#### 問題：內存不足
```bash
MemoryError: Unable to allocate array
```

**解決方案：**
```python
# 1. 減少數據存儲
class MemoryEfficientSimulator:
    def __init__(self):
        self.max_history = 1000  # 限制歷史記錄
        
    def add_event(self, event):
        if len(self.events) > self.max_history:
            self.events.pop(0)  # 移除最舊的事件

# 2. 使用數據庫存儲
import sqlite3

class DatabaseMetrics:
    def __init__(self):
        self.conn = sqlite3.connect(':memory:')
        
    def store_event(self, event):
        # 存儲到數據庫而非內存

# 3. 定期清理
def cleanup_memory():
    import gc
    gc.collect()
```

### 容器化問題

#### 問題：Docker 構建失敗
```bash
ERROR: failed to solve: process "/bin/sh -c pip install -r requirements.txt" did not complete successfully
```

**解決方案：**
```dockerfile
# 1. 檢查 Dockerfile 語法
FROM python:3.9-slim

# 設置工作目錄
WORKDIR /app

# 先複製 requirements.txt
COPY requirements.txt .

# 安裝依賴
RUN pip install --no-cache-dir -r requirements.txt

# 再複製其他文件
COPY . .

# 2. 檢查 requirements.txt 格式
# 確保沒有額外的空行或特殊字符

# 3. 使用多階段構建
FROM python:3.9-slim as builder
COPY requirements.txt .
RUN pip install --user -r requirements.txt

FROM python:3.9-slim
COPY --from=builder /root/.local /root/.local
COPY . .
```

#### 問題：容器權限問題
```bash
Permission denied: '/app/data'
```

**解決方案：**
```dockerfile
# 1. 創建非 root 用戶
RUN adduser --disabled-password --gecos '' appuser
RUN chown -R appuser:appuser /app
USER appuser

# 2. 或調整文件權限
RUN chmod 755 /app
RUN chmod 644 /app/data

# 3. 使用 volume 掛載
docker run -v $(pwd)/data:/app/data bee-swarm
```

## ⚡ 性能問題

### 模擬性能優化

#### 問題：模擬速度太慢
**診斷方法：**
```python
import time
import cProfile

def profile_simulation():
    profiler = cProfile.Profile()
    profiler.enable()
    
    # 運行模擬
    run_simulation()
    
    profiler.disable()
    profiler.print_stats(sort='cumulative')

# 性能監控
def monitor_performance():
    start_time = time.time()
    memory_before = psutil.virtual_memory().used
    
    # 執行操作
    result = expensive_operation()
    
    end_time = time.time()
    memory_after = psutil.virtual_memory().used
    
    print(f"執行時間: {end_time - start_time:.2f}秒")
    print(f"內存使用: {(memory_after - memory_before) / 1024 / 1024:.2f}MB")
```

**優化策略：**
```python
# 1. 使用更高效的數據結構
from collections import deque, defaultdict
import heapq

class EfficientSimulator:
    def __init__(self):
        self.event_queue = []  # 使用 heapq
        self.metrics = defaultdict(deque)  # 使用 deque
        
    def schedule_event(self, time, event):
        heapq.heappush(self.event_queue, (time, event))

# 2. 並行處理
from multiprocessing import Pool
import concurrent.futures

def run_parallel_simulations(scenarios):
    with concurrent.futures.ProcessPoolExecutor() as executor:
        futures = [executor.submit(run_simulation, scenario) 
                  for scenario in scenarios]
        results = [future.result() for future in futures]
    return results

# 3. 批量處理
def batch_process_tasks(tasks, batch_size=100):
    for i in range(0, len(tasks), batch_size):
        batch = tasks[i:i + batch_size]
        process_batch(batch)
```

### 系統資源問題

#### 問題：CPU 使用率過高
**監控方法：**
```python
import psutil
import time

def monitor_system_resources():
    print(f"CPU 使用率: {psutil.cpu_percent()}%")
    print(f"內存使用率: {psutil.virtual_memory().percent}%")
    print(f"磁盤使用率: {psutil.disk_usage('/').percent}%")

# 限制 CPU 使用
import os
def limit_cpu_usage():
    os.nice(10)  # 降低優先級
```

**解決方案：**
```python
# 1. 添加延遲
import time

def cpu_friendly_loop():
    for item in large_dataset:
        process_item(item)
        time.sleep(0.001)  # 小延遲

# 2. 使用生成器
def memory_efficient_processing():
    for item in yield_items():  # 逐個生成
        yield process_item(item)

# 3. 分片處理
def chunked_processing(data, chunk_size=1000):
    for i in range(0, len(data), chunk_size):
        chunk = data[i:i + chunk_size]
        process_chunk(chunk)
        time.sleep(0.1)  # 讓系統休息
```

## 🔄 流程問題

### 協作流程問題

#### 問題：PR 審查延遲
**症狀：** Pull Request 長時間沒有審查

**解決方案：**
```yaml
# 1. 設置自動分配審查者
# .github/CODEOWNERS
* @team-lead @senior-dev

# 2. GitHub Actions 提醒
name: PR Review Reminder
on:
  schedule:
    - cron: '0 9 * * 1-5'  # 工作日每天 9 點

jobs:
  reminder:
    runs-on: ubuntu-latest
    steps:
      - name: Check pending PRs
        run: |
          # 檢查待審查的 PR 並發送提醒

# 3. 設置 PR 模板
<!-- Pull Request Template -->
## 審查要求
- [ ] 需要至少 2 人審查
- [ ] 測試通過
- [ ] 文檔已更新

## 審查者
@reviewer1 @reviewer2
```

#### 問題：分支策略混亂
**症狀：** 多個分支同時開發，合併衝突頻繁

**解決方案：**
```bash
# 1. 採用 Git Flow 策略
git flow init

# 創建功能分支
git flow feature start new-feature

# 完成功能開發
git flow feature finish new-feature

# 2. 或使用 GitHub Flow
git checkout main
git pull origin main
git checkout -b feature/description
# 開發並提交
git push origin feature/description
# 創建 PR

# 3. 設置分支保護規則
# GitHub Settings > Branches > Add rule
# - Require PR reviews
# - Require status checks
# - Require branches to be up to date
```

### CI/CD 問題

#### 問題：部署失敗
**症狀：** 自動部署流程中斷

**診斷步驟：**
```bash
# 1. 檢查部署日誌
kubectl logs deployment/app-deployment

# 2. 檢查服務狀態
kubectl get pods
kubectl describe pod <pod-name>

# 3. 檢查配置
kubectl get configmap
kubectl get secret

# 4. 檢查網絡
kubectl get service
kubectl get ingress
```

**解決方案：**
```yaml
# 1. 添加健康檢查
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: app
        image: app:latest
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

# 2. 設置回滾策略
spec:
  revisionHistoryLimit: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
```

## 📊 監控和診斷工具

### 日誌分析

#### 結構化日誌
```python
import logging
import json
from datetime import datetime

class StructuredLogger:
    def __init__(self, name):
        self.logger = logging.getLogger(name)
        handler = logging.StreamHandler()
        handler.setFormatter(self.JSONFormatter())
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    class JSONFormatter(logging.Formatter):
        def format(self, record):
            log_entry = {
                'timestamp': datetime.utcnow().isoformat(),
                'level': record.levelname,
                'message': record.getMessage(),
                'module': record.module,
                'function': record.funcName,
                'line': record.lineno
            }
            return json.dumps(log_entry)

# 使用示例
logger = StructuredLogger('bee_swarm')
logger.logger.info("Simulation started", extra={'duration': 300})
```

#### 日誌聚合
```bash
# 1. 使用 grep 搜索日誌
grep "ERROR" logs/*.log

# 2. 使用 awk 分析日誌
awk '/ERROR/ {count++} END {print "Error count:", count}' app.log

# 3. 使用 jq 分析 JSON 日誌
cat app.log | jq '.level == "ERROR"'

# 4. 實時監控
tail -f app.log | grep --color "ERROR\|WARNING"
```

### 性能監控

#### 系統監控腳本
```bash
#!/bin/bash
# monitor.sh - 系統監控腳本

while true; do
    echo "=== $(date) ==="
    echo "CPU: $(top -bn1 | grep '%Cpu' | awk '{print $2}' | cut -d'%' -f1)"
    echo "Memory: $(free | grep '^Mem' | awk '{printf "%.2f%%", $3/$2 * 100.0}')"
    echo "Disk: $(df -h / | awk 'NR==2{print $5}')"
    echo ""
    sleep 60
done
```

#### 應用監控
```python
import time
import psutil
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        start_memory = psutil.virtual_memory().used
        
        result = func(*args, **kwargs)
        
        end_time = time.time()
        end_memory = psutil.virtual_memory().used
        
        print(f"{func.__name__} 性能統計:")
        print(f"  執行時間: {end_time - start_time:.2f}秒")
        print(f"  內存變化: {(end_memory - start_memory) / 1024 / 1024:.2f}MB")
        
        return result
    return wrapper

@monitor_performance
def expensive_simulation():
    # 執行模擬
    pass
```

## 📝 問題報告模板

### Bug 報告
```markdown
## Bug 報告

### 環境信息
- 操作系統：macOS 12.5
- Python 版本：3.9.13
- 相關依賴版本：simpy 4.0.1

### 問題描述
簡潔描述遇到的問題。

### 重現步驟
1. 步驟一
2. 步驟二
3. 步驟三

### 期望行為
描述期望的正確行為。

### 實際行為
描述實際發生的錯誤行為。

### 錯誤日誌
```
paste error logs here
```

### 額外信息
添加任何其他有助於診斷的信息。
```

### 性能問題報告
```markdown
## 性能問題報告

### 性能指標
- 執行時間：預期 vs 實際
- 內存使用：預期 vs 實際
- CPU 使用率：峰值和平均值

### 測試環境
- 硬件配置
- 數據集大小
- 併發數量

### 性能分析
- 瓶頸識別
- 熱點函數
- 資源限制

### 優化建議
- 短期改進方案
- 長期優化策略
```

## 本章小結

### 關鍵要點
- **系統性診斷** 比隨機嘗試更有效
- **日誌記錄** 是問題診斷的重要工具
- **監控預警** 能及早發現問題
- **文檔記錄** 幫助積累解決經驗

### 與其他章節的關聯
- 第2章：系統架構影響問題類型
- 第5章：模擬工具的具體問題
- 第7章：部署運維問題解決

### 下一步建議
1. 建立問題知識庫
2. 設置監控和告警
3. 制定標準診斷流程
4. 定期進行問題回顧

## 參考資料

- [Python 調試指南](https://docs.python.org/3/library/pdb.html)
- [Docker 故障排除](https://docs.docker.com/config/daemon/logs/)
- [GitHub Actions 調試](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows)
- [系統性能監控](https://www.brendangregg.com/perf.html) 