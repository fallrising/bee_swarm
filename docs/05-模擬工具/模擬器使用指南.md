# 模擬器使用指南

## 📋 概述

Bee Swarm 項目使用 SimPy 離散事件模擬框架來驗證 AI 角色協作流程的有效性。通過模擬真實的開發協作場景，我們可以評估不同配置下的團隊效率、資源利用率和潛在瓶頸。

## 🎯 模擬目標

### 核心驗證目標
- **協作效率**: 評估 AI 角色間的協作效率
- **資源利用**: 分析計算資源和時間的使用情況
- **瓶頸識別**: 發現協作流程中的潛在瓶頸
- **擴展性**: 測試系統在不同規模下的表現

### 業務價值評估
- **交付週期**: 從需求到發布的完整週期時間
- **質量指標**: 缺陷率、返工率、用戶滿意度
- **成本效益**: 人力成本、基礎設施成本分析
- **風險評估**: 項目風險和失敗概率分析

## 🛠 環境搭建

### 依賴安裝
```bash
# 創建虛擬環境
python -m venv bee_swarm_sim
source bee_swarm_sim/bin/activate  # Linux/Mac
# 或 bee_swarm_sim\Scripts\activate  # Windows

# 安裝依賴
pip install simpy
pip install numpy pandas matplotlib seaborn
pip install jupyter notebook
pip install plotly dash  # 用於交互式可視化
pip install pyyaml  # 配置文件解析
```

### 項目結構
```
simulation/
├── config/
│   ├── scenarios.yaml          # 模擬場景配置
│   ├── roles.yaml             # 角色配置參數
│   └── environments.yaml      # 環境配置
├── src/
│   ├── core/
│   │   ├── simulation.py      # 核心模擬引擎
│   │   ├── events.py          # 事件定義
│   │   └── metrics.py         # 指標收集
│   ├── roles/
│   │   ├── base_role.py       # 角色基類
│   │   ├── product_manager.py # 產品經理模擬
│   │   ├── backend_dev.py     # 後端開發者模擬
│   │   ├── frontend_dev.py    # 前端開發者模擬
│   │   └── devops_engineer.py # DevOps 工程師模擬
│   ├── workflows/
│   │   ├── task_management.py # 任務管理模擬
│   │   ├── code_review.py     # 代碼評審模擬
│   │   └── deployment.py     # 部署流程模擬
│   └── utils/
│       ├── logger.py          # 日誌記錄
│       ├── visualizer.py      # 結果可視化
│       └── reporter.py        # 報告生成
├── data/
│   ├── input/                 # 輸入數據
│   └── output/                # 模擬結果
├── notebooks/
│   ├── analysis.ipynb         # 結果分析
│   └── visualization.ipynb    # 可視化展示
└── scripts/
    ├── run_simulation.py      # 運行模擬
    └── batch_analysis.py      # 批量分析
```

## ⚙️ 配置文件說明

### 場景配置 (scenarios.yaml)
```yaml
scenarios:
  basic_development:
    name: "基礎開發流程"
    description: "標準的功能開發和發布流程"
    duration: 30  # 模擬天數
    project_complexity: "medium"
    team_size: 4
    workload_pattern: "normal"
    
  high_pressure:
    name: "高壓開發場景"
    description: "緊急項目和高並發開發"
    duration: 15
    project_complexity: "high"
    team_size: 6
    workload_pattern: "intensive"
    
  scale_testing:
    name: "規模擴展測試"
    description: "測試大規模團隊協作"
    duration: 60
    project_complexity: "high"
    team_size: 12
    workload_pattern: "normal"

parameters:
  task_arrival_rate: 
    min: 2    # 每天最少任務數
    max: 8    # 每天最多任務數
    distribution: "poisson"
  
  task_complexity:
    simple: 0.3    # 30% 簡單任務
    medium: 0.5    # 50% 中等任務  
    complex: 0.2   # 20% 複雜任務
    
  interruption_rate: 0.1  # 任務中斷率
  rework_probability: 0.15  # 返工概率
```

### 角色配置 (roles.yaml)
```yaml
roles:
  product_manager:
    name: "產品經理"
    capacity: 8  # 每日工作小時
    skills:
      requirement_analysis: 0.9
      stakeholder_communication: 0.8
      priority_management: 0.85
    
    task_types:
      - requirement_gathering
      - user_story_writing
      - stakeholder_meeting
      - priority_review
    
    performance:
      review_time: 
        mean: 30    # 分鐘
        std: 10
      decision_time:
        mean: 60
        std: 20
        
  backend_developer:
    name: "後端開發者"
    capacity: 8
    skills:
      coding: 0.9
      system_design: 0.8
      database_design: 0.85
      api_development: 0.9
    
    task_types:
      - feature_development
      - bug_fixing
      - code_review
      - system_optimization
    
    performance:
      coding_speed:
        simple_task: {mean: 4, std: 1}    # 小時
        medium_task: {mean: 8, std: 2}
        complex_task: {mean: 16, std: 4}
      review_time: {mean: 45, std: 15}    # 分鐘
      
  frontend_developer:
    name: "前端開發者"
    capacity: 8
    skills:
      ui_development: 0.9
      ux_implementation: 0.8
      responsive_design: 0.85
      performance_optimization: 0.8
    
    task_types:
      - ui_development
      - component_creation
      - integration_testing
      - performance_tuning
    
    performance:
      coding_speed:
        simple_task: {mean: 3, std: 1}
        medium_task: {mean: 6, std: 2}
        complex_task: {mean: 12, std: 3}
      review_time: {mean: 30, std: 10}
      
  devops_engineer:
    name: "DevOps 工程師"
    capacity: 8
    skills:
      infrastructure_management: 0.9
      cicd_pipeline: 0.85
      monitoring: 0.8
      security: 0.8
    
    task_types:
      - deployment
      - infrastructure_setup
      - monitoring_configuration
      - security_implementation
    
    performance:
      deployment_time: {mean: 30, std: 10}  # 分鐘
      setup_time: {mean: 120, std: 30}      # 分鐘
      troubleshooting_time: {mean: 90, std: 20}
```

## 🚀 使用示例

### 基礎模擬運行
```python
# scripts/run_simulation.py
import simpy
import yaml
from src.core.simulation import BeeSwarmSimulation
from src.utils.visualizer import SimulationVisualizer

def main():
    # 加載配置
    with open('config/scenarios.yaml', 'r') as f:
        scenarios = yaml.safe_load(f)
    
    with open('config/roles.yaml', 'r') as f:
        roles_config = yaml.safe_load(f)
    
    # 選擇場景
    scenario = scenarios['scenarios']['basic_development']
    
    # 創建模擬環境
    env = simpy.Environment()
    simulation = BeeSwarmSimulation(env, scenario, roles_config)
    
    # 運行模擬
    print(f"開始模擬: {scenario['name']}")
    print(f"模擬時長: {scenario['duration']} 天")
    
    env.run(until=scenario['duration'] * 24)  # 轉換為小時
    
    # 收集結果
    metrics = simulation.get_metrics()
    
    # 生成報告
    visualizer = SimulationVisualizer()
    visualizer.generate_report(metrics, 'basic_development_report.html')
    
    print("模擬完成，報告已生成")

if __name__ == "__main__":
    main()
```

### 核心模擬引擎
```python
# src/core/simulation.py
import simpy
import random
import numpy as np
from typing import Dict, List, Any
from ..roles.base_role import BaseRole
from ..roles.product_manager import ProductManager
from ..roles.backend_dev import BackendDeveloper
from ..roles.frontend_dev import FrontendDeveloper
from ..roles.devops_engineer import DevOpsEngineer

class BeeSwarmSimulation:
    def __init__(self, env: simpy.Environment, scenario: Dict, roles_config: Dict):
        self.env = env
        self.scenario = scenario
        self.roles_config = roles_config
        
        # 初始化角色
        self.roles = self._initialize_roles()
        
        # 初始化任務隊列
        self.task_queue = simpy.Store(env)
        self.completed_tasks = []
        
        # 初始化 GitHub 模擬
        self.github_issues = simpy.Store(env)
        self.github_prs = simpy.Store(env)
        
        # 啟動進程
        self.env.process(self._task_generator())
        self.env.process(self._github_coordinator())
        
        # 指標收集
        self.metrics = {
            'task_completion_times': [],
            'role_utilization': {role.name: [] for role in self.roles},
            'github_activity': {'issues': [], 'prs': []},
            'collaboration_events': []
        }
    
    def _initialize_roles(self) -> List[BaseRole]:
        """初始化 AI 角色"""
        roles = []
        
        # 創建產品經理
        pm_config = self.roles_config['roles']['product_manager']
        pm = ProductManager(self.env, pm_config, self)
        roles.append(pm)
        
        # 創建開發者
        backend_config = self.roles_config['roles']['backend_developer']
        backend_dev = BackendDeveloper(self.env, backend_config, self)
        roles.append(backend_dev)
        
        frontend_config = self.roles_config['roles']['frontend_developer']
        frontend_dev = FrontendDeveloper(self.env, frontend_config, self)
        roles.append(frontend_dev)
        
        # 創建 DevOps 工程師
        devops_config = self.roles_config['roles']['devops_engineer']
        devops = DevOpsEngineer(self.env, devops_config, self)
        roles.append(devops)
        
        return roles
    
    def _task_generator(self):
        """任務生成器"""
        params = self.scenario.get('parameters', {})
        arrival_rate = params.get('task_arrival_rate', {'min': 2, 'max': 8})
        
        while True:
            # 每天生成一批任務
            daily_tasks = random.randint(arrival_rate['min'], arrival_rate['max'])
            
            for _ in range(daily_tasks):
                task = self._generate_task()
                yield self.task_queue.put(task)
                
                # 記錄到 GitHub Issues
                issue = {
                    'id': f"issue-{len(self.metrics['github_activity']['issues']) + 1}",
                    'task': task,
                    'created_at': self.env.now,
                    'status': 'open'
                }
                yield self.github_issues.put(issue)
                self.metrics['github_activity']['issues'].append(issue)
            
            # 等待到第二天
            yield self.env.timeout(24)  # 24小時
    
    def _generate_task(self) -> Dict:
        """生成任務"""
        task_types = ['feature_development', 'bug_fixing', 'optimization', 'testing']
        complexity_levels = ['simple', 'medium', 'complex']
        priorities = ['low', 'medium', 'high', 'critical']
        
        task = {
            'id': f"task-{len(self.completed_tasks) + len(self.metrics['github_activity']['issues']) + 1}",
            'type': random.choice(task_types),
            'complexity': np.random.choice(
                complexity_levels, 
                p=[0.3, 0.5, 0.2]  # 30% simple, 50% medium, 20% complex
            ),
            'priority': random.choice(priorities),
            'estimated_hours': self._estimate_task_hours(),
            'created_at': self.env.now,
            'dependencies': [],
            'assigned_roles': []
        }
        
        return task
    
    def _estimate_task_hours(self) -> float:
        """估算任務工時"""
        return max(1, np.random.lognormal(2, 0.8))  # 對數正態分佈
    
    def _github_coordinator(self):
        """GitHub 協調器模擬"""
        while True:
            # 檢查 Issues 狀態
            # 檢查 PR 狀態
            # 觸發自動化工作流
            yield self.env.timeout(1)  # 每小時檢查一次
    
    def record_collaboration_event(self, event_type: str, participants: List[str], details: Dict):
        """記錄協作事件"""
        event = {
            'type': event_type,
            'timestamp': self.env.now,
            'participants': participants,
            'details': details
        }
        self.metrics['collaboration_events'].append(event)
    
    def get_metrics(self) -> Dict:
        """獲取模擬指標"""
        return self.metrics
```

### 角色基類
```python
# src/roles/base_role.py
import simpy
import random
from typing import Dict, List, Any
from abc import ABC, abstractmethod

class BaseRole(ABC):
    def __init__(self, env: simpy.Environment, config: Dict, simulation):
        self.env = env
        self.config = config
        self.simulation = simulation
        self.name = config['name']
        self.capacity = config['capacity']  # 每日工作小時
        self.skills = config['skills']
        
        # 工作狀態
        self.current_task = None
        self.workload = simpy.Resource(env, capacity=1)
        self.daily_hours_worked = 0
        self.utilization_history = []
        
        # 啟動工作進程
        self.env.process(self._work_loop())
        self.env.process(self._daily_reset())
    
    def _work_loop(self):
        """主要工作循環"""
        while True:
            # 檢查是否有可用工作時間
            if self.daily_hours_worked >= self.capacity:
                yield self.env.timeout(1)  # 等待一小時
                continue
            
            # 尋找合適的任務
            task = yield from self._find_suitable_task()
            
            if task:
                yield from self._execute_task(task)
            else:
                # 沒有任務時進行其他活動
                yield from self._idle_activities()
    
    def _daily_reset(self):
        """每日重置工作時間"""
        while True:
            yield self.env.timeout(24)  # 等待24小時
            
            # 記錄利用率
            utilization = self.daily_hours_worked / self.capacity
            self.utilization_history.append({
                'day': self.env.now // 24,
                'utilization': utilization,
                'hours_worked': self.daily_hours_worked
            })
            
            self.simulation.metrics['role_utilization'][self.name].append(utilization)
            
            # 重置每日工作時間
            self.daily_hours_worked = 0
    
    @abstractmethod
    def _find_suitable_task(self):
        """尋找適合的任務（每個角色實現不同）"""
        pass
    
    @abstractmethod
    def _execute_task(self, task):
        """執行任務（每個角色實現不同）"""
        pass
    
    def _idle_activities(self):
        """空閑時間活動"""
        activities = ['learning', 'documentation', 'code_review', 'planning']
        activity = random.choice(activities)
        duration = random.uniform(0.5, 2)  # 0.5-2小時
        
        print(f"{self.name} 進行 {activity} 活動，耗時 {duration:.1f} 小時")
        
        with self.workload.request() as req:
            yield req
            yield self.env.timeout(duration)
            self.daily_hours_worked += duration
    
    def get_skill_level(self, skill: str) -> float:
        """獲取技能水平"""
        return self.skills.get(skill, 0.5)  # 默認中等水平
    
    def collaborate_with(self, other_role: 'BaseRole', task: Dict, collaboration_type: str):
        """與其他角色協作"""
        collaboration_time = random.uniform(0.5, 2)  # 協作時間
        
        self.simulation.record_collaboration_event(
            collaboration_type,
            [self.name, other_role.name],
            {'task_id': task['id'], 'duration': collaboration_time}
        )
        
        return collaboration_time
```

## 📊 結果分析

### 關鍵指標
```python
# src/utils/visualizer.py
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

class SimulationVisualizer:
    def __init__(self):
        plt.style.use('seaborn')
        sns.set_palette("husl")
    
    def generate_report(self, metrics: Dict, output_file: str):
        """生成完整的模擬報告"""
        
        # 創建子圖
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=(
                '角色利用率趨勢', '任務完成時間分佈',
                '協作頻率分析', 'GitHub 活動統計',
                '性能指標對比', '瓶頸分析'
            ),
            specs=[[{"secondary_y": True}, {"type": "histogram"}],
                   [{"type": "bar"}, {"type": "pie"}],
                   [{"type": "radar"}, {"type": "scatter"}]]
        )
        
        # 1. 角色利用率趨勢
        self._plot_utilization_trends(fig, metrics, row=1, col=1)
        
        # 2. 任務完成時間分佈
        self._plot_completion_time_distribution(fig, metrics, row=1, col=2)
        
        # 3. 協作頻率分析
        self._plot_collaboration_frequency(fig, metrics, row=2, col=1)
        
        # 4. GitHub 活動統計
        self._plot_github_activity(fig, metrics, row=2, col=2)
        
        # 5. 性能指標對比
        self._plot_performance_comparison(fig, metrics, row=3, col=1)
        
        # 6. 瓶頸分析
        self._plot_bottleneck_analysis(fig, metrics, row=3, col=2)
        
        # 更新佈局
        fig.update_layout(
            title="Bee Swarm 協作模擬分析報告",
            height=1200,
            showlegend=True
        )
        
        # 保存報告
        fig.write_html(output_file)
        print(f"報告已保存到: {output_file}")
    
    def _plot_utilization_trends(self, fig, metrics, row, col):
        """繪製利用率趨勢"""
        for role_name, utilization_data in metrics['role_utilization'].items():
            fig.add_trace(
                go.Scatter(
                    y=utilization_data,
                    mode='lines+markers',
                    name=f'{role_name} 利用率',
                    line=dict(width=2)
                ),
                row=row, col=col
            )
    
    def _plot_completion_time_distribution(self, fig, metrics, row, col):
        """繪製任務完成時間分佈"""
        completion_times = metrics['task_completion_times']
        
        fig.add_trace(
            go.Histogram(
                x=completion_times,
                nbinsx=20,
                name='完成時間分佈',
                opacity=0.7
            ),
            row=row, col=col
        )
    
    def _plot_collaboration_frequency(self, fig, metrics, row, col):
        """繪製協作頻率"""
        collaboration_counts = {}
        for event in metrics['collaboration_events']:
            event_type = event['type']
            collaboration_counts[event_type] = collaboration_counts.get(event_type, 0) + 1
        
        fig.add_trace(
            go.Bar(
                x=list(collaboration_counts.keys()),
                y=list(collaboration_counts.values()),
                name='協作事件頻率'
            ),
            row=row, col=col
        )
    
    def _plot_github_activity(self, fig, metrics, row, col):
        """繪製 GitHub 活動統計"""
        issues_count = len(metrics['github_activity']['issues'])
        prs_count = len(metrics['github_activity']['prs'])
        
        fig.add_trace(
            go.Pie(
                labels=['Issues', 'Pull Requests'],
                values=[issues_count, prs_count],
                name="GitHub 活動"
            ),
            row=row, col=col
        )
    
    def _plot_performance_comparison(self, fig, metrics, row, col):
        """繪製性能指標對比"""
        # 雷達圖顯示各角色的綜合性能
        categories = ['效率', '質量', '協作', '創新']
        
        for role_name in metrics['role_utilization'].keys():
            # 計算各項指標（示例數據）
            efficiency = sum(metrics['role_utilization'][role_name]) / len(metrics['role_utilization'][role_name])
            quality = 0.85  # 假設質量指標
            collaboration = 0.75  # 假設協作指標
            innovation = 0.65  # 假設創新指標
            
            values = [efficiency, quality, collaboration, innovation]
            
            fig.add_trace(
                go.Scatterpolar(
                    r=values,
                    theta=categories,
                    fill='toself',
                    name=role_name
                ),
                row=row, col=col
            )
    
    def _plot_bottleneck_analysis(self, fig, metrics, row, col):
        """繪製瓶頸分析"""
        # 分析任務排隊時間和角色負載
        role_names = list(metrics['role_utilization'].keys())
        avg_utilization = [
            sum(metrics['role_utilization'][role]) / len(metrics['role_utilization'][role])
            for role in role_names
        ]
        
        fig.add_trace(
            go.Scatter(
                x=role_names,
                y=avg_utilization,
                mode='markers',
                marker=dict(
                    size=[u*100 for u in avg_utilization],
                    color=avg_utilization,
                    colorscale='Viridis',
                    showscale=True
                ),
                name='角色負載'
            ),
            row=row, col=col
        )
```

## 🔧 高級配置

### 批量實驗配置
```python
# scripts/batch_analysis.py
import itertools
from concurrent.futures import ProcessPoolExecutor

def run_batch_experiments():
    """運行批量實驗"""
    
    # 定義參數範圍
    team_sizes = [4, 6, 8, 12]
    complexities = ['low', 'medium', 'high']
    workload_patterns = ['normal', 'intensive', 'relaxed']
    
    # 生成所有組合
    experiments = list(itertools.product(team_sizes, complexities, workload_patterns))
    
    print(f"總共 {len(experiments)} 個實驗配置")
    
    # 並行運行實驗
    with ProcessPoolExecutor(max_workers=4) as executor:
        results = executor.map(run_single_experiment, experiments)
    
    # 分析結果
    analyze_batch_results(list(results))

def run_single_experiment(params):
    """運行單個實驗"""
    team_size, complexity, workload = params
    
    # 創建實驗配置
    experiment_config = {
        'team_size': team_size,
        'complexity': complexity,
        'workload_pattern': workload,
        'duration': 30
    }
    
    # 運行模擬
    env = simpy.Environment()
    simulation = BeeSwarmSimulation(env, experiment_config, roles_config)
    env.run(until=30 * 24)
    
    return {
        'config': experiment_config,
        'metrics': simulation.get_metrics()
    }
```

## 📈 性能調優

### 模擬性能優化
```python
# 使用 Cython 加速關鍵計算
# setup.py
from setuptools import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize("src/core/fast_simulation.pyx")
)

# src/core/fast_simulation.pyx
import numpy as np
cimport numpy as np
cimport cython

@cython.boundscheck(False)
@cython.wraparound(False)
def calculate_utilization_fast(double[:] work_hours, double capacity):
    """快速計算利用率"""
    cdef int n = work_hours.shape[0]
    cdef double total = 0.0
    cdef int i
    
    for i in range(n):
        total += work_hours[i]
    
    return total / (n * capacity)
```

---

> **注意**: 這是 Bee Swarm 模擬工具的使用指南。根據具體需求調整配置參數，可以獲得更準確的模擬結果。建議從簡單場景開始，逐步增加複雜度。 