# ç¬¬2.3ç«  é€šä¿¡èˆ‡å”èª¿æ©Ÿåˆ¶

## æœ¬ç« æ¦‚è¦

- **ç« ç¯€ç›®æ¨™**ï¼šæ·±å…¥ç†è§£ Bee Swarm çš„é€šä¿¡å”èª¿æ©Ÿåˆ¶è¨­è¨ˆ
- **ä¸»è¦å…§å®¹**ï¼šGitHub-Centric é€šä¿¡ã€ç•°æ­¥å”èª¿æ¨¡å¼ã€ç‹€æ…‹ç®¡ç†ã€è¡çªè§£æ±º
- **é–±è®€æ”¶ç©«**ï¼šæŒæ¡ AI è§’è‰²é–“çš„é€šä¿¡å”è­°å’Œå”èª¿ç­–ç•¥

## è©³ç´°å…§å®¹

### ğŸ“¡ GitHub-Centric é€šä¿¡æ©Ÿåˆ¶

#### é€šä¿¡æ¶æ§‹æ¦‚è¦½

```mermaid
graph TB
    subgraph "GitHub é€šä¿¡ä¸­å¿ƒ"
        A[Issues ä»»å‹™é€šä¿¡]
        B[Comments è¨è«–é€šä¿¡]  
        C[Pull Requests ä»£ç¢¼é€šä¿¡]
        D[Projects ç‹€æ…‹é€šä¿¡]
        E[Actions äº‹ä»¶é€šä¿¡]
        F[Wiki çŸ¥è­˜é€šä¿¡]
    end
    
    subgraph "AI è§’è‰²é€šä¿¡å±¤"
        G[Product Manager]
        H[Backend Developer]
        I[Frontend Developer] 
        J[DevOps Engineer]
    end
    
    subgraph "é€šä¿¡å”è­°å±¤"
        K[æ¶ˆæ¯æ ¼å¼æ¨™æº–]
        L[ç‹€æ…‹åŒæ­¥å”è­°]
        M[äº‹ä»¶è§¸ç™¼æ©Ÿåˆ¶]
        N[éŒ¯èª¤è™•ç†å”è­°]
    end
    
    A <--> G
    A <--> H
    A <--> I
    A <--> J
    
    B <--> G
    B <--> H
    B <--> I
    B <--> J
    
    C <--> H
    C <--> I
    C <--> J
    
    D <--> G
    
    E <--> G
    E <--> H
    E <--> I
    E <--> J
    
    G -.-> K
    H -.-> K
    I -.-> K
    J -.-> K
    
    K --> L
    K --> M
    K --> N
```

#### GitHub åŠŸèƒ½æ˜ å°„

**åŠŸèƒ½å°æ‡‰é—œä¿‚**
```
Issuesï¼š
â”œâ”€â”€ ä»»å‹™å‰µå»ºå’Œåˆ†é… â†’ å·¥ä½œé …ç®¡ç†
â”œâ”€â”€ éœ€æ±‚è¨è«–å’Œæ¾„æ¸… â†’ æ¥­å‹™æºé€š
â”œâ”€â”€ é€²åº¦è·Ÿè¸ªå’Œæ›´æ–° â†’ ç‹€æ…‹ç®¡ç†
â””â”€â”€ å•é¡Œå ±å‘Šå’Œè§£æ±º â†’ ç•°å¸¸è™•ç†

Commentsï¼š
â”œâ”€â”€ å¯¦æ™‚è¨è«–å’Œå”å•† â†’ åŒæ­¥é€šä¿¡
â”œâ”€â”€ æ±ºç­–è¨˜éŒ„å’Œèªªæ˜ â†’ çŸ¥è­˜ç®¡ç†
â”œâ”€â”€ ä»£ç¢¼å¯©æŸ¥æ„è¦‹ â†’ è³ªé‡æ§åˆ¶
â””â”€â”€ æŠ€è¡“æ–¹æ¡ˆè¨è«– â†’ æ¶æ§‹è¨­è¨ˆ

Pull Requestsï¼š
â”œâ”€â”€ ä»£ç¢¼è®Šæ›´ææ¡ˆ â†’ ç‰ˆæœ¬æ§åˆ¶
â”œâ”€â”€ ä»£ç¢¼å¯©æŸ¥æµç¨‹ â†’ è³ªé‡ä¿è­‰
â”œâ”€â”€ é›†æˆæ¸¬è©¦è§¸ç™¼ â†’ è‡ªå‹•åŒ–æµç¨‹
â””â”€â”€ éƒ¨ç½²æº–å‚™æª¢æŸ¥ â†’ ç™¼å¸ƒç®¡ç†

Projectsï¼š
â”œâ”€â”€ å·¥ä½œæµå¯è¦–åŒ– â†’ é …ç›®ç®¡ç†
â”œâ”€â”€ ä»»å‹™ç‹€æ…‹è¿½è¹¤ â†’ é€²åº¦ç›£æ§
â”œâ”€â”€ è³‡æºåˆ†é…ç®¡ç† â†’ è² è¼‰å‡è¡¡
â””â”€â”€ é‡Œç¨‹ç¢‘è¦åŠƒ â†’ æ™‚é–“ç®¡ç†
```

### ğŸ”„ ç•°æ­¥å”èª¿æ¨¡å¼

#### å”èª¿æ¨¡å¼è¨­è¨ˆ

**äº‹ä»¶é©…å‹•å”èª¿**
```mermaid
sequenceDiagram
    participant U as ç”¨æˆ¶
    participant GH as GitHub
    participant PM as ç”¢å“ç¶“ç†
    participant DEV as é–‹ç™¼è€…
    participant DO as DevOps
    
    Note over U,DO: äº‹ä»¶è§¸ç™¼éšæ®µ
    U->>GH: å‰µå»º Issue
    GH->>GH: è§¸ç™¼ webhook
    GH->>PM: ç™¼é€é€šçŸ¥äº‹ä»¶
    
    Note over U,DO: ç•°æ­¥è™•ç†éšæ®µ
    PM->>PM: åˆ†æéœ€æ±‚
    PM->>GH: æ›´æ–° Issue ç‹€æ…‹
    PM->>GH: å‰µå»ºå­ä»»å‹™
    
    Note over U,DO: ç´šè¯è§¸ç™¼éšæ®µ
    GH->>DEV: é€šçŸ¥æ–°ä»»å‹™
    GH->>DO: é€šçŸ¥åŸºç¤è¨­æ–½éœ€æ±‚
    
    Note over U,DO: ä¸¦è¡ŒåŸ·è¡Œéšæ®µ
    par é–‹ç™¼å·¥ä½œ
        DEV->>DEV: å¯¦ç¾åŠŸèƒ½
        DEV->>GH: æäº¤ä»£ç¢¼
    and é‹ç¶­æº–å‚™
        DO->>DO: æº–å‚™ç’°å¢ƒ
        DO->>GH: æ›´æ–°é…ç½®
    end
    
    Note over U,DO: ç‹€æ…‹åŒæ­¥éšæ®µ
    GH->>PM: åŒ¯ç¸½é€²åº¦
    PM->>GH: æ›´æ–°é …ç›®ç‹€æ…‹
```

**æ™‚é–“çª—å£å”èª¿**
```python
class TimeWindowCoordinator:
    def __init__(self, window_size=30):  # 30åˆ†é˜çª—å£
        self.window_size = window_size
        self.active_window = None
        self.pending_actions = []
    
    def schedule_action(self, action, priority=1):
        """èª¿åº¦è¡Œå‹•åˆ°æ™‚é–“çª—å£"""
        if not self.active_window:
            self.active_window = TimeWindow(
                start=datetime.now(),
                duration=self.window_size
            )
        
        self.active_window.add_action(action, priority)
    
    def execute_window(self):
        """åŸ·è¡Œç•¶å‰æ™‚é–“çª—å£çš„æ‰€æœ‰è¡Œå‹•"""
        if not self.active_window:
            return
        
        # æŒ‰å„ªå…ˆç´šæ’åºåŸ·è¡Œ
        sorted_actions = sorted(
            self.active_window.actions,
            key=lambda x: x.priority,
            reverse=True
        )
        
        results = []
        for action in sorted_actions:
            try:
                result = action.execute()
                results.append(result)
            except Exception as e:
                self.handle_action_error(action, e)
        
        self.active_window = None
        return results
```

#### ç‹€æ…‹ä¸€è‡´æ€§ä¿è­‰

**ç‹€æ…‹åŒæ­¥æ©Ÿåˆ¶**
```python
class StateSync:
    def __init__(self, github_client):
        self.github = github_client
        self.state_cache = {}
        self.sync_interval = 300  # 5åˆ†é˜
    
    def sync_issue_state(self, issue_id):
        """åŒæ­¥ Issue ç‹€æ…‹"""
        # å¾ GitHub ç²å–æœ€æ–°ç‹€æ…‹
        latest_state = self.github.get_issue(issue_id)
        
        # æª¢æŸ¥æœ¬åœ°ç·©å­˜
        cached_state = self.state_cache.get(issue_id)
        
        if not cached_state or latest_state.updated_at > cached_state.updated_at:
            # æ›´æ–°æœ¬åœ°ç‹€æ…‹
            self.state_cache[issue_id] = latest_state
            
            # é€šçŸ¥ç›¸é—œè§’è‰²
            self.notify_state_change(issue_id, latest_state)
            
        return latest_state
    
    def notify_state_change(self, issue_id, state):
        """é€šçŸ¥ç‹€æ…‹è®Šæ›´"""
        # è­˜åˆ¥ç›¸é—œè§’è‰²
        assignees = state.assignees
        labels = [label.name for label in state.labels]
        
        # ç™¼é€é€šçŸ¥
        for assignee in assignees:
            role = self.get_role_by_assignee(assignee)
            if role:
                role.handle_state_change(issue_id, state)
```

### ğŸ“‹ æ¶ˆæ¯æ ¼å¼èˆ‡å”è­°

#### æ¨™æº–åŒ–æ¶ˆæ¯æ ¼å¼

**Issue æ¶ˆæ¯æ¨¡æ¿**
```markdown
## ğŸ¯ ä»»å‹™ä¿¡æ¯
- **ä»»å‹™ID**: #{issue_number}
- **ä»»å‹™é¡å‹**: Feature/Bug/Enhancement/Research
- **å„ªå…ˆç´š**: Critical/High/Medium/Low
- **é ä¼°å·¥æœŸ**: X å¤©
- **æˆªæ­¢æ—¥æœŸ**: YYYY-MM-DD

## ğŸ“‹ ä»»å‹™æè¿°
### èƒŒæ™¯èªªæ˜
ç°¡è¦æè¿°ä»»å‹™çš„æ¥­å‹™èƒŒæ™¯å’Œå¿…è¦æ€§...

### åŠŸèƒ½éœ€æ±‚
è©³ç´°æè¿°éœ€è¦å¯¦ç¾çš„åŠŸèƒ½...

### æŠ€è¡“éœ€æ±‚
åˆ—å‡ºæŠ€è¡“å¯¦ç¾çš„å…·é«”è¦æ±‚...

## âœ… é©—æ”¶æ¨™æº–
- [ ] åŠŸèƒ½æ¨™æº–1
- [ ] åŠŸèƒ½æ¨™æº–2  
- [ ] æ€§èƒ½æ¨™æº–1
- [ ] è³ªé‡æ¨™æº–1

## ğŸ”— ç›¸é—œè³‡æº
- [è¨­è¨ˆæ–‡æª”](link)
- [API è¦ç¯„](link)
- [æ¸¬è©¦è¨ˆåŠƒ](link)

## ğŸ‘¥ è§’è‰²åˆ†å·¥
- **ç”¢å“ç¶“ç†**: @pm - éœ€æ±‚æ¾„æ¸…å’Œé©—æ”¶
- **å¾Œç«¯é–‹ç™¼**: @backend - API å¯¦ç¾
- **å‰ç«¯é–‹ç™¼**: @frontend - ç•Œé¢å¯¦ç¾
- **DevOps**: @devops - éƒ¨ç½²é…ç½®

## ğŸ“Š é€²åº¦è·Ÿè¸ª
- [ ] éœ€æ±‚åˆ†æ (PM)
- [ ] æŠ€è¡“è¨­è¨ˆ (DEV)
- [ ] é–‹ç™¼å¯¦ç¾ (DEV) 
- [ ] æ¸¬è©¦é©—è­‰ (QA)
- [ ] éƒ¨ç½²ä¸Šç·š (DevOps)
```

**Comment é€šä¿¡å”è­°**
```markdown
## è§’è‰²é€šä¿¡æ ¼å¼

### ç‹€æ…‹æ›´æ–°
```json
{
  "type": "status_update",
  "role": "backend_developer",
  "task": "#123",
  "status": "in_progress",
  "progress": 65,
  "eta": "2024-12-25T15:00:00Z",
  "blockers": []
}
```

### å”ä½œè«‹æ±‚
```json
{
  "type": "collaboration_request", 
  "from_role": "backend_developer",
  "to_role": "frontend_developer",
  "task": "#123",
  "request_type": "api_spec_review",
  "priority": "high",
  "details": {
    "api_endpoint": "/api/v1/users",
    "specification_url": "link_to_spec"
  }
}
```

### å•é¡Œå ±å‘Š
```json
{
  "type": "issue_report",
  "role": "frontend_developer", 
  "task": "#123",
  "issue_type": "api_error",
  "severity": "medium",
  "description": "API è¿”å›æ ¼å¼èˆ‡è¦ç¯„ä¸ç¬¦",
  "reproduction_steps": ["step1", "step2", "step3"]
}
```
```

#### API èª¿ç”¨å”è­°

**GitHub API åŒ…è£å™¨**
```python
class GitHubCommunicator:
    def __init__(self, token, rate_limit_strategy='adaptive'):
        self.github = Github(token)
        self.rate_limiter = RateLimiter(strategy=rate_limit_strategy)
        self.retry_config = RetryConfig(max_retries=3, backoff_factor=2)
    
    def create_issue(self, title, body, labels=None, assignees=None):
        """å‰µå»º Issue"""
        with self.rate_limiter:
            try:
                issue = self.github.get_repo().create_issue(
                    title=title,
                    body=body,
                    labels=labels or [],
                    assignees=assignees or []
                )
                return issue
            except GithubException as e:
                return self.handle_github_error(e)
    
    def add_comment(self, issue_number, comment_body):
        """æ·»åŠ è©•è«–"""
        with self.rate_limiter:
            issue = self.github.get_repo().get_issue(issue_number)
            return issue.create_comment(comment_body)
    
    def update_issue_status(self, issue_number, state, labels=None):
        """æ›´æ–° Issue ç‹€æ…‹"""
        with self.rate_limiter:
            issue = self.github.get_repo().get_issue(issue_number)
            if state:
                issue.edit(state=state)
            if labels:
                issue.set_labels(*labels)
            return issue
```

### âš¡ äº‹ä»¶è§¸ç™¼æ©Ÿåˆ¶

#### Webhook äº‹ä»¶è™•ç†

**äº‹ä»¶è·¯ç”±ç³»çµ±**
```python
class EventRouter:
    def __init__(self):
        self.handlers = {}
        self.middleware = []
    
    def register_handler(self, event_type, handler):
        """è¨»å†Šäº‹ä»¶è™•ç†å™¨"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        self.handlers[event_type].append(handler)
    
    def handle_webhook(self, payload):
        """è™•ç† Webhook äº‹ä»¶"""
        event_type = payload.get('action')
        event_data = payload.get('data', {})
        
        # åŸ·è¡Œä¸­é–“ä»¶
        for middleware in self.middleware:
            event_data = middleware.process(event_data)
        
        # æŸ¥æ‰¾ä¸¦åŸ·è¡Œè™•ç†å™¨
        handlers = self.handlers.get(event_type, [])
        results = []
        
        for handler in handlers:
            try:
                result = handler.process(event_data)
                results.append(result)
            except Exception as e:
                self.log_handler_error(handler, e)
        
        return results

# äº‹ä»¶è™•ç†å™¨ç¤ºä¾‹
class IssueCreatedHandler:
    def __init__(self, role_dispatcher):
        self.dispatcher = role_dispatcher
    
    def process(self, event_data):
        issue = event_data['issue']
        
        # åˆ†æ Issue æ¨™ç±¤ç¢ºå®šç›®æ¨™è§’è‰²
        target_roles = self.analyze_required_roles(issue.labels)
        
        # åˆ†æ´¾çµ¦ç›¸æ‡‰è§’è‰²
        for role in target_roles:
            self.dispatcher.assign_task(role, issue)
```

#### GitHub Actions é›†æˆ

**è‡ªå‹•åŒ–å·¥ä½œæµè§¸ç™¼**
```yaml
# .github/workflows/ai-collaboration.yml
name: AI Collaboration Trigger

on:
  issues:
    types: [opened, edited, assigned, labeled]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, synchronize, closed]
  schedule:
    - cron: '*/30 * * * *'

jobs:
  dispatch-to-roles:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Parse Event
        id: parse
        run: |
          echo "event_type=${{ github.event_name }}" >> $GITHUB_OUTPUT
          echo "action=${{ github.event.action }}" >> $GITHUB_OUTPUT
      
      - name: Dispatch to Product Manager
        if: contains(github.event.issue.labels.*.name, 'needs-analysis')
        run: |
          curl -X POST ${{ secrets.PM_WEBHOOK_URL }} \
            -H "Content-Type: application/json" \
            -d '{"event": "${{ steps.parse.outputs.event_type }}", "issue": ${{ toJson(github.event.issue) }}}'
      
      - name: Dispatch to Developers
        if: contains(github.event.issue.labels.*.name, 'development')
        run: |
          # æ ¹æ“šæ¨™ç±¤åˆ†æ´¾çµ¦ä¸åŒé–‹ç™¼è€…è§’è‰²
          if [[ "${{ contains(github.event.issue.labels.*.name, 'backend') }}" == "true" ]]; then
            curl -X POST ${{ secrets.BACKEND_WEBHOOK_URL }} \
              -H "Content-Type: application/json" \
              -d '{"event": "${{ steps.parse.outputs.event_type }}", "issue": ${{ toJson(github.event.issue) }}}'
          fi
```

### ğŸ› ï¸ è¡çªè§£æ±ºæ©Ÿåˆ¶

#### è¡çªæª¢æ¸¬

**è¡çªé¡å‹è­˜åˆ¥**
```python
class ConflictDetector:
    def __init__(self):
        self.conflict_rules = [
            ResourceConflictRule(),
            ScheduleConflictRule(), 
            DependencyConflictRule(),
            PriorityConflictRule()
        ]
    
    def detect_conflicts(self, task_assignments):
        """æª¢æ¸¬ä»»å‹™åˆ†é…ä¸­çš„è¡çª"""
        conflicts = []
        
        for rule in self.conflict_rules:
            rule_conflicts = rule.check(task_assignments)
            conflicts.extend(rule_conflicts)
        
        return self.prioritize_conflicts(conflicts)
    
    def prioritize_conflicts(self, conflicts):
        """è¡çªå„ªå…ˆç´šæ’åº"""
        return sorted(conflicts, key=lambda c: c.severity, reverse=True)

class ResourceConflictRule:
    def check(self, assignments):
        """æª¢æŸ¥è³‡æºè¡çª"""
        conflicts = []
        resource_usage = {}
        
        for assignment in assignments:
            for resource in assignment.required_resources:
                if resource in resource_usage:
                    conflicts.append(ResourceConflict(
                        resource=resource,
                        conflicting_tasks=[resource_usage[resource], assignment],
                        severity='high'
                    ))
                else:
                    resource_usage[resource] = assignment
        
        return conflicts
```

#### è¡çªè§£æ±ºç­–ç•¥

**è‡ªå‹•è§£æ±ºæ©Ÿåˆ¶**
```python
class ConflictResolver:
    def __init__(self):
        self.resolution_strategies = {
            'resource_conflict': self.resolve_resource_conflict,
            'schedule_conflict': self.resolve_schedule_conflict,
            'dependency_conflict': self.resolve_dependency_conflict,
            'priority_conflict': self.resolve_priority_conflict
        }
    
    def resolve_conflict(self, conflict):
        """è§£æ±ºè¡çª"""
        strategy = self.resolution_strategies.get(conflict.type)
        if strategy:
            return strategy(conflict)
        else:
            return self.escalate_to_human(conflict)
    
    def resolve_resource_conflict(self, conflict):
        """è§£æ±ºè³‡æºè¡çª"""
        # ç­–ç•¥1ï¼šæ™‚é–“åˆ†ç‰‡
        if self.can_time_slice(conflict.resource):
            return self.create_time_slices(conflict)
        
        # ç­–ç•¥2ï¼šå„ªå…ˆç´šèª¿åº¦
        if self.has_priority_difference(conflict.tasks):
            return self.reschedule_by_priority(conflict)
        
        # ç­–ç•¥3ï¼šå°‹æ‰¾æ›¿ä»£è³‡æº
        alternative = self.find_alternative_resource(conflict.resource)
        if alternative:
            return self.reassign_resource(conflict, alternative)
        
        # ç­–ç•¥4ï¼šå»¶é²ä½å„ªå…ˆç´šä»»å‹™
        return self.delay_low_priority_task(conflict)
    
    def resolve_schedule_conflict(self, conflict):
        """è§£æ±ºæ™‚é–“è¡çª"""
        # åˆ†æä»»å‹™çš„éˆæ´»æ€§
        flexibility = self.analyze_task_flexibility(conflict.tasks)
        
        # å„ªå…ˆèª¿æ•´éˆæ´»æ€§é«˜çš„ä»»å‹™
        flexible_task = max(flexibility.items(), key=lambda x: x[1])[0]
        new_schedule = self.reschedule_task(flexible_task)
        
        return ScheduleResolution(
            original_conflict=conflict,
            adjusted_task=flexible_task,
            new_schedule=new_schedule
        )
```

### ğŸ“Š é€šä¿¡æ•ˆç‡ç›£æ§

#### é€šä¿¡æŒ‡æ¨™æ”¶é›†

```python
class CommunicationMetrics:
    def __init__(self):
        self.metrics = {
            'message_count': Counter(),
            'response_time': defaultdict(list),
            'collaboration_efficiency': defaultdict(float),
            'conflict_resolution_time': defaultdict(list)
        }
    
    def track_message(self, from_role, to_role, message_type, timestamp):
        """è·Ÿè¸ªæ¶ˆæ¯ç™¼é€"""
        self.metrics['message_count'][f"{from_role}->{to_role}"] += 1
        
        # è¨˜éŒ„æ¶ˆæ¯æ™‚é–“æˆ³ç”¨æ–¼è¨ˆç®—éŸ¿æ‡‰æ™‚é–“
        message_id = f"{from_role}-{to_role}-{timestamp}"
        self.pending_responses[message_id] = timestamp
    
    def track_response(self, to_role, from_role, response_timestamp):
        """è·Ÿè¸ªéŸ¿æ‡‰æ™‚é–“"""
        # æŸ¥æ‰¾å°æ‡‰çš„åŸå§‹æ¶ˆæ¯
        for msg_id, sent_time in self.pending_responses.items():
            if f"{to_role}-{from_role}" in msg_id:
                response_time = response_timestamp - sent_time
                self.metrics['response_time'][f"{to_role}-{from_role}"].append(
                    response_time.total_seconds()
                )
                del self.pending_responses[msg_id]
                break
    
    def calculate_collaboration_score(self, role_pair):
        """è¨ˆç®—å”ä½œæ•ˆç‡è©•åˆ†"""
        message_key = f"{role_pair[0]}->{role_pair[1]}"
        response_key = f"{role_pair[1]}-{role_pair[0]}"
        
        # æ¶ˆæ¯æ•¸é‡å› å­
        msg_count = self.metrics['message_count'][message_key]
        msg_score = min(msg_count / 10, 1.0)  # æ­£è¦åŒ–åˆ°0-1
        
        # éŸ¿æ‡‰æ™‚é–“å› å­
        response_times = self.metrics['response_time'][response_key]
        if response_times:
            avg_response = sum(response_times) / len(response_times)
            # éŸ¿æ‡‰æ™‚é–“è¶ŠçŸ­åˆ†æ•¸è¶Šé«˜ï¼ˆä»¥1å°æ™‚ç‚ºåŸºæº–ï¼‰
            time_score = max(0, 1 - avg_response / 3600)
        else:
            time_score = 0
        
        # ç¶œåˆè©•åˆ†
        collaboration_score = (msg_score * 0.4 + time_score * 0.6)
        self.metrics['collaboration_efficiency'][message_key] = collaboration_score
        
        return collaboration_score
```

#### æ€§èƒ½å„ªåŒ–å»ºè­°

**é€šä¿¡ç“¶é ¸åˆ†æ**
```python
class CommunicationAnalyzer:
    def analyze_bottlenecks(self, metrics):
        """åˆ†æé€šä¿¡ç“¶é ¸"""
        bottlenecks = []
        
        # éŸ¿æ‡‰æ™‚é–“ç“¶é ¸
        for role_pair, times in metrics['response_time'].items():
            if times:
                avg_time = sum(times) / len(times)
                if avg_time > 3600:  # è¶…é1å°æ™‚
                    bottlenecks.append({
                        'type': 'response_time',
                        'role_pair': role_pair,
                        'avg_time': avg_time,
                        'severity': 'high' if avg_time > 7200 else 'medium'
                    })
        
        # é€šä¿¡é »ç‡ç“¶é ¸
        for role_pair, count in metrics['message_count'].items():
            if count > 50:  # æ¶ˆæ¯éå¤šå¯èƒ½è¡¨ç¤ºå”ä½œæ•ˆç‡ä½
                bottlenecks.append({
                    'type': 'high_frequency',
                    'role_pair': role_pair,
                    'message_count': count,
                    'severity': 'medium'
                })
        
        return bottlenecks
    
    def suggest_optimizations(self, bottlenecks):
        """æä¾›å„ªåŒ–å»ºè­°"""
        suggestions = []
        
        for bottleneck in bottlenecks:
            if bottleneck['type'] == 'response_time':
                suggestions.append({
                    'target': bottleneck['role_pair'],
                    'action': 'reduce_response_time',
                    'methods': [
                        'èª¿æ•´æª¢æŸ¥é »ç‡',
                        'å„ªåŒ–ä»»å‹™å„ªå…ˆç´š',
                        'å¢åŠ è‡ªå‹•åŒ–ç¨‹åº¦'
                    ]
                })
            elif bottleneck['type'] == 'high_frequency':
                suggestions.append({
                    'target': bottleneck['role_pair'],
                    'action': 'reduce_communication_overhead',
                    'methods': [
                        'æ‰¹é‡è™•ç†æ¶ˆæ¯',
                        'æ”¹é€²å”ä½œæµç¨‹',
                        'ä½¿ç”¨æ›´é«˜æ•ˆçš„å”ä½œæ¨¡å¼'
                    ]
                })
        
        return suggestions
```

## å¯¦è¸æŒ‡å—

### é€šä¿¡å”è­°å¯¦æ–½

1. **é…ç½® Webhook ç«¯é»**
   ```python
   # webhook_handler.py
   from flask import Flask, request, jsonify
   
   app = Flask(__name__)
   
   @app.route('/webhook/github', methods=['POST'])
   def handle_github_webhook():
       payload = request.get_json()
       event_type = request.headers.get('X-GitHub-Event')
       
       # è·¯ç”±åˆ°ç›¸æ‡‰è™•ç†å™¨
       router = EventRouter()
       results = router.handle_webhook({
           'type': event_type,
           'data': payload
       })
       
       return jsonify({'status': 'processed', 'results': len(results)})
   ```

2. **å¯¦ç¾è§’è‰²é€šä¿¡æ¥å£**
   ```python
   class RoleCommunicationInterface:
       def __init__(self, role_id, github_client):
           self.role_id = role_id
           self.github = github_client
           self.message_queue = MessageQueue()
       
       def send_message(self, target_role, message_type, content):
           """ç™¼é€æ¶ˆæ¯çµ¦å…¶ä»–è§’è‰²"""
           message = self.format_message(target_role, message_type, content)
           return self.github.add_comment(message['issue_id'], message['body'])
       
       def process_incoming_messages(self):
           """è™•ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯"""
           messages = self.message_queue.get_pending_messages()
           for message in messages:
               self.handle_message(message)
   ```

### ç›£æ§å„€è¡¨æ¿è¨­ç½®

```python
# monitoring_dashboard.py
class CommunicationDashboard:
    def __init__(self, metrics_collector):
        self.metrics = metrics_collector
        self.dashboard = self.create_dashboard()
    
    def create_dashboard(self):
        """å‰µå»ºç›£æ§å„€è¡¨æ¿"""
        dashboard = {
            'real_time_metrics': self.create_realtime_panel(),
            'historical_trends': self.create_trends_panel(),
            'bottleneck_analysis': self.create_bottleneck_panel(),
            'optimization_suggestions': self.create_suggestions_panel()
        }
        return dashboard
    
    def update_dashboard(self):
        """æ›´æ–°å„€è¡¨æ¿æ•¸æ“š"""
        current_metrics = self.metrics.get_current_metrics()
        self.dashboard['real_time_metrics'].update(current_metrics)
        
        # ç”Ÿæˆè¶¨å‹¢åœ–
        trend_data = self.metrics.get_historical_data(days=7)
        self.dashboard['historical_trends'].update(trend_data)
        
        # åˆ†æç“¶é ¸
        analyzer = CommunicationAnalyzer()
        bottlenecks = analyzer.analyze_bottlenecks(current_metrics)
        suggestions = analyzer.suggest_optimizations(bottlenecks)
        
        self.dashboard['bottleneck_analysis'] = bottlenecks
        self.dashboard['optimization_suggestions'] = suggestions
```

## æœ¬ç« å°çµ

### é—œéµè¦é»ç¸½çµ
1. **GitHub-Centric é€šä¿¡æ©Ÿåˆ¶**åˆ©ç”¨ GitHub åŸç”ŸåŠŸèƒ½å¯¦ç¾é€æ˜çš„å”ä½œé€šä¿¡
2. **ç•°æ­¥å”èª¿æ¨¡å¼**é€šéäº‹ä»¶é©…å‹•å’Œæ™‚é–“çª—å£æ©Ÿåˆ¶å¯¦ç¾é«˜æ•ˆå”èª¿
3. **æ¨™æº–åŒ–æ¶ˆæ¯æ ¼å¼**ç¢ºä¿è§’è‰²é–“é€šä¿¡çš„ä¸€è‡´æ€§å’Œå¯ç†è§£æ€§
4. **è¡çªè§£æ±ºæ©Ÿåˆ¶**æä¾›è‡ªå‹•åŒ–çš„è¡çªæª¢æ¸¬å’Œè§£æ±ºç­–ç•¥
5. **é€šä¿¡æ•ˆç‡ç›£æ§**é€šéæŒ‡æ¨™æ”¶é›†å’Œåˆ†ææŒçºŒå„ªåŒ–å”ä½œæ•ˆç‡

### èˆ‡å…¶ä»–ç« ç¯€çš„é—œè¯
- **å‰ç½®ç« ç¯€**ï¼š[AIè§’è‰²è¨­è¨ˆ](AIè§’è‰²è¨­è¨ˆ.md) - è§’è‰²é–“å¦‚ä½•é€²è¡Œé€šä¿¡
- **ä¸‹ä¸€ç« **ï¼š[ç•°æ­¥å”ä½œæµç¨‹](../03-å·¥ä½œæµç¨‹/ç•°æ­¥å”ä½œæµç¨‹.md) - é€šä¿¡åœ¨å·¥ä½œæµä¸­çš„æ‡‰ç”¨
- **å¯¦è¸ç« ç¯€**ï¼š[é…ç½®æŒ‡å—](../06-ä½¿ç”¨æŒ‡å—/é…ç½®æŒ‡å—.md) - é€šä¿¡æ©Ÿåˆ¶çš„å…·é«”é…ç½®

### ä¸‹ä¸€æ­¥å»ºè­°
1. æ·±å…¥äº†è§£ GitHub API çš„ä½¿ç”¨æ–¹æ³•å’Œé™åˆ¶
2. å¯¦è¸ç•°æ­¥å”èª¿æ¨¡å¼çš„è¨­è¨ˆå’Œå¯¦ç¾
3. å­¸ç¿’è¡çªè§£æ±ºç­–ç•¥çš„æ‡‰ç”¨å ´æ™¯

## åƒè€ƒè³‡æ–™

- [GitHub Webhooks æ–‡æª”](https://docs.github.com/en/developers/webhooks-and-events/webhooks)
- [åˆ†æ•£å¼ç³»çµ±ä¸€è‡´æ€§ç†è«–](#)
- [ç•°æ­¥å”ä½œæ¨¡å¼ç ”ç©¶](#)
- [äº‹ä»¶é©…å‹•æ¶æ§‹è¨­è¨ˆæ¨¡å¼](#)

---

*æœ¬ç« æ·±å…¥ä»‹ç´¹äº† Bee Swarm çš„é€šä¿¡èˆ‡å”èª¿æ©Ÿåˆ¶ï¼Œå±•ç¤ºäº†å¦‚ä½•åŸºæ–¼ GitHub å¹³å°å¯¦ç¾é«˜æ•ˆçš„ç•°æ­¥å”ä½œã€‚* 